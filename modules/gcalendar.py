import pickle
import os.path

from datetime import datetime
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request
from modules.trybacker import retry_with_backoff, offline_queue


class GCalendar:
    def __init__(self, title, event_amount):
        self.title = title                         # The name of the calendar
        self.event_amount = event_amount           # How many events to load if update smaller than full sync
        self.credentials_file = 'credentials.json' # You should get this from the Google API Console (https://console.developers.google.com/)
        self.pickle = 'token.pickle'               # This file is automatically generated by the Google API Python Integration
        self.scopes = ['https://www.googleapis.com/auth/calendar'] # Scope of your API
        self.service = self._setup_service()       # Google API Service Object
        self.id = self.get_calendar_id()           # Google Calendar ID (not the name)
        self.events = None

    @staticmethod
    def _end_with_msg(msg):
        print(msg)
        exit()

    # Setup Google API Service Object to interact with Google Calendar
    def _setup_service(self):
        creds = None
        # The file token.pickle stores the user's access and refresh tokens, and is
        # created automatically when the authorization flow completes for the first time.
        if os.path.exists(self.pickle):
            with open(self.pickle, 'rb') as token:
                creds = pickle.load(token)
        
        # If no (valid) credentials available, let the user log in.
        if not creds or not creds.valid:
            if creds and creds.expired and creds.refresh_token:
                creds.refresh(Request())
            else:
                flow = InstalledAppFlow.from_client_secrets_file(self.credentials_file, self.scopes)
                creds = flow.run_local_server(port=0)

            # Save the credentials for the next run
            with open(self.pickle, 'wb') as token:
                pickle.dump(creds, token)
        
        return build("calendar", "v3", credentials=creds)

    # Get the ID of the calendar with the name self.title
    @retry_with_backoff(max_retries=3, base_delay=2.0)
    def get_calendar_id(self):
        print('>> Reading Google Calendar "%s"' % self.title)
        calendars_result = self.service.calendarList().list().execute()
        calendars = calendars_result.get('items', [])

        if not calendars:
            self._end_with_msg('[!] - No calendars found!')

        for calendar in calendars:
            if calendar["summary"] == self.title:
                return calendar["id"]

        self._end_with_msg("[!] - Calendar not found. Please make sure it exists.")

    # Retrieve events from Google Calendar
    @retry_with_backoff(max_retries=3, base_delay=2.0)
    def load_events(self, full_sync):
        now = datetime.utcnow().isoformat() + "Z"

        if full_sync:
            print(">> Getting everything there is")
            self.events = []
            page_token = None
            while True:
                events_result = (
                    self.service.events()
                    .list(
                        calendarId=self.id,
                        timeMin=now,
                        singleEvents=True,
                        orderBy="startTime",
                        pageToken=page_token,
                    )
                    .execute()
                )
                self.events.extend(events_result.get("items", []))
                page_token = events_result.get("nextPageToken")
                if not page_token:
                    break
        else:
            print(">> Getting list of", self.event_amount, "upcoming events")
            events_result = (
                self.service.events()
                .list(
                    calendarId=self.id,
                    timeMin=now,
                    maxResults=self.event_amount,
                    singleEvents=True,
                    orderBy="startTime",
                )
                .execute()
            )
            self.events = events_result.get("items", [])

    # Create new event in Google Calendar with retry, queue on persistent failure
    def create_event(self, event):
        event_data = {
            "summary": event[1],
            "location": event[2],
            "description": event[3]
            + " # [Created:"
            + event[0].strftime("%d-%m-%Y %H:%M:%S")
            + "] # [Pulled: "
            + datetime.now().strftime("%d-%m-%Y %H:%M:%S")
            + "]",
            "start": {"dateTime": event[4].isoformat(), "timeZone": "Europe/Berlin"},
            "end": {"dateTime": event[5].isoformat(), "timeZone": "Europe/Berlin"},
        }
        try:
            self._create_event_api(event_data)
        except HttpError:
            offline_queue.add("create_event", event_data)

    @retry_with_backoff(max_retries=3, base_delay=2.0)
    def _create_event_api(self, event_data):
        self.service.events().insert(calendarId=self.id, body=event_data).execute()

    # Mark existing event in Google Calendar as outdated (seems better to me than outright deleting it)
    def outdate_event(self, event_id, keep_history=True):
        if keep_history:
            try:
                self._outdate_event_api(event_id)
            except HttpError:
                offline_queue.add("outdate_event", {"event_id": event_id})
        else:
            self.delete_event(event_id)

    @retry_with_backoff(max_retries=3, base_delay=2.0)
    def _outdate_event_api(self, event_id):
        event = (
            self.service.events().get(calendarId=self.id, eventId=event_id).execute()
        )
        description = event.get("description", "")
        if "OUTDATED" in description:
            return
        event["description"] = description + " # OUTDATED"
        self.service.events().update(
            calendarId=self.id, eventId=event_id, body=event
        ).execute()

    def delete_event(self, event_id):
        # Delete event with retry, queue on persistent failure
        try:
            self._delete_event_api(event_id)
        except HttpError:
            offline_queue.add("delete_event", {"event_id": event_id})

    @retry_with_backoff(max_retries=3, base_delay=2.0)
    def _delete_event_api(self, event_id):
        self.service.events().delete(calendarId=self.id, eventId=event_id).execute()

    def process_offline_queue(self):
        # Process queued operations from previous, recorded failures
        pending = offline_queue.get_pending()
        if not pending:
            return

        print(f">> Processing {len(pending)} queued operations...")
        processed = []

        for i, op in enumerate(pending):
            try:
                if op["operation"] == "create_event":
                    self._create_event_api(op["data"])
                    processed.append(i)
                elif op["operation"] == "outdate_event":
                    self._outdate_event_api(op["data"]["event_id"])
                    processed.append(i)
                elif op["operation"] == "delete_event":
                    self._delete_event_api(op["data"]["event_id"])
                    processed.append(i)
                print(f"\t[OK] {op['operation']}")
            except HttpError:
                print(f"\t[FAIL] {op['operation']} - will retry later")

        for i in reversed(processed):
            offline_queue.remove(i)
